---
title: [BJ-2751] 수 정렬하기 2
slug: bj-2751
date_published: 2023-01-17T07:29:38.000Z
date_updated: 2023-01-17T07:29:38.000Z
tags: 알고리즘, 백준
---

[

2751번: 수 정렬하기 2

![](https://www.acmicpc.net/apple-touch-icon.png)Baekjoon Online Judge스타트링크 (Startlink)

![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/images/boj-og.png)
](https://www.acmicpc.net/problem/2751)
## 풀이

- 이 문제부터는 제한시간 내 처리하기 빠듯하기 때문에 `Scanner` 와 `System.out` 객체가 아니라 `BufferedReader` 객체와 `BufferedWriter` 객체를 사용하는 것이 좋다.
- 시간복잡도 $O(NLogN)$ 을 가지는 정렬(퀵, 머지) 로 해결할 수 있다.
- 내장함수 사용하지 않고 직접 구현할 것이라면 머지 정렬로 구현하는것이 좋다.
- 퀵 정렬은 최악의 경우 시간복잡도 $O(N^2)$ 을 가지기 때문

## 코드

    import java.io.*;
    import java.util.Arrays;
    import java.util.StringTokenizer;
    
    public class Main {
        public static void main(String[] args) throws IOException {
    
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
    
            int tc = Integer.parseInt(br.readLine());
    
            int[] arr = new int[tc];
    
            for (int i = 0; i < tc; i++) {
                StringTokenizer st = new StringTokenizer(br.readLine());
                arr[i] = Integer.parseInt(st.nextToken());
            }
    
            int[] result = splitAndMerge(arr);
    
            for (int token : result) {
                bw.write(String.valueOf(token));
                bw.newLine();
            }
            bw.flush();
            bw.close();
        }
    
        public static int[] splitAndMerge(int[] arr) {
    
            int[] frontArr = Arrays.copyOfRange(arr, 0, arr.length / 2);
            int[] backArr = Arrays.copyOfRange(arr, arr.length / 2, arr.length);
    
            //재귀 분할이 필요한 경우
            if(frontArr.length >= 2) {
                frontArr = splitAndMerge(frontArr);
            }
            if(backArr.length >= 2){
                backArr = splitAndMerge(backArr);
            }
    
            return merge(frontArr, backArr);
        }
    
        public static int[] merge(int[] arr1, int[] arr2) {
    
            int idx1 = 0;
            int idx2 = 0;
    
            int maxIdx1 = arr1.length - 1;
            int maxIdx2 = arr2.length - 1;
    
            int[] result = new int[arr1.length + arr2.length];
    
            while (idx1 <= maxIdx1 || idx2 <= maxIdx2) {
    
                int currentIdx = idx1 + idx2;
    
                if (idx1 > maxIdx1) {
                    result[currentIdx] = arr2[idx2++];
                    continue;
                } else if (idx2 > maxIdx2) {
                    result[currentIdx] = arr1[idx1++];
                    continue;
                }
    
                result[currentIdx] = arr1[idx1] < arr2[idx2] ? arr1[idx1++] : arr2[idx2++];
            }
    
            return result;
        }
    }
    
